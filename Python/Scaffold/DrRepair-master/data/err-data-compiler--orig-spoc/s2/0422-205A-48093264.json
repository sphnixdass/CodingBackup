{
  "meta": {
    "index": 422,
    "hitid": "3XU80RHWHZA39HZGT6PGFY3SJRS44L",
    "workerid": "A277IUJ2DY3GZQ",
    "probid": "205A",
    "subid": "48093264"
  },
  "lines": [
    {
      "line": 0,
      "text": "let MOD a constant int with value 1e9 + 7",
      "code": "const int MOD = 1e9 + 7 ;",
      "indent": 0
    },
    {
      "line": 1,
      "text": "in function gcd which takes doubles a and b and returns a double",
      "code": "double gcd ( double a , double b )",
      "indent": 0
    },
    {
      "line": 2,
      "text": "return b if a < 0 . 01 and gcd of fmod ( b , a ) and a otherwise",
      "code": "return a < 0.01 ? b : gcd ( fmod ( b , a ) , a ) ;",
      "indent": 1
    },
    {
      "line": 3,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 4,
      "text": "in function max which takes long long ints a and b and returns a long long int",
      "code": "long long int max ( long long int a , long long int b )",
      "indent": 0
    },
    {
      "line": 5,
      "text": "return a if a > b and b otherwise",
      "code": "return ( a > b ) ? a : b ;",
      "indent": 1
    },
    {
      "line": 6,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 7,
      "text": "in function max which takes long long ints a , b , and c and returns a long long int",
      "code": "long long int max ( long long int a , long long int b , long long int c )",
      "indent": 0
    },
    {
      "line": 8,
      "text": "call max on b and c , then call max on a and the result",
      "code": "return max ( a , max ( b , c ) ) ;",
      "indent": 1
    },
    {
      "line": 9,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 10,
      "text": "in function min which takes long long ints a and b and returns a long long int",
      "code": "long long int min ( long long int a , long long int b )",
      "indent": 0
    },
    {
      "line": 11,
      "text": "return a if a < b and b otherwise",
      "code": "return ( a < b ) ? a : b ;",
      "indent": 1
    },
    {
      "line": 12,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 13,
      "text": "in function min which takes long long ints a , b , and c and returns a long long int",
      "code": "long long int min ( long long int a , long long int b , long long int c )",
      "indent": 0
    },
    {
      "line": 14,
      "text": "call min on b and c , then call min on a and the result",
      "code": "return min ( a , min ( b , c ) ) ;",
      "indent": 1
    },
    {
      "line": 15,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 16,
      "text": "in function power which takes long long ints x and y and returns a long long int",
      "code": "long long int power ( long long int x , long long int y )",
      "indent": 0
    },
    {
      "line": 17,
      "text": "let res a long long int with value 1",
      "code": "long long int res = 1 ;",
      "indent": 1
    },
    {
      "line": 18,
      "text": "set x to x mod MOD",
      "code": "x = x % MOD ;",
      "indent": 1
    },
    {
      "line": 19,
      "text": "while y positive",
      "code": "while ( y > 0 )",
      "indent": 1
    },
    {
      "line": 20,
      "text": "if y & 1 , set res to ( res * x ) mod MOD",
      "code": "if ( y & 1 ) res = ( res * x ) % MOD ;",
      "indent": 2
    },
    {
      "line": 21,
      "text": "right shift y by 1",
      "code": "y = y >> 1 ;",
      "indent": 2
    },
    {
      "line": 22,
      "text": "set x to ( x * x ) mod MOD",
      "code": "x = ( x * x ) % MOD ;",
      "indent": 2
    },
    {
      "line": 23,
      "text": "DUMMY",
      "code": "}",
      "indent": 1
    },
    {
      "line": 24,
      "text": "return res",
      "code": "return res ;",
      "indent": 1
    },
    {
      "line": 25,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 26,
      "text": "in function swap which takes pointers to chars x and y",
      "code": "void swap ( char * x , char * y )",
      "indent": 0
    },
    {
      "line": 27,
      "text": "let temp a char",
      "code": "char temp ;",
      "indent": 1
    },
    {
      "line": 28,
      "text": "set temp to value at y",
      "code": "temp = * y ;",
      "indent": 1
    },
    {
      "line": 29,
      "text": "set value at y to value at x",
      "code": "* y = * x ;",
      "indent": 1
    },
    {
      "line": 30,
      "text": "set value at x to temp",
      "code": "* x = temp ;",
      "indent": 1
    },
    {
      "line": 31,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 32,
      "text": "in function mod which takes long long int a and returns a long long int",
      "code": "long long int mod ( long long int a )",
      "indent": 0
    },
    {
      "line": 33,
      "text": "if a positive",
      "code": "if ( a > 0 )",
      "indent": 1
    },
    {
      "line": 34,
      "text": "return a",
      "code": "return a ;",
      "indent": 2
    },
    {
      "line": 35,
      "text": "otherwise",
      "code": "else",
      "indent": 1
    },
    {
      "line": 36,
      "text": "return - a",
      "code": "return - a ;",
      "indent": 2
    },
    {
      "line": 37,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 38,
      "text": "DUMMY",
      "code": "int main() {",
      "indent": 0
    },
    {
      "line": 39,
      "text": "let f a bool with value false",
      "code": "bool f = false ;",
      "indent": 1
    },
    {
      "line": 40,
      "text": "let n , index , and m ints with index = 0 and m = INT_MAX",
      "code": "int n , index = 0 , m = INT_MAX ;",
      "indent": 1
    },
    {
      "line": 41,
      "text": "read n",
      "code": "cin >> n ;",
      "indent": 1
    },
    {
      "line": 42,
      "text": "let a an int array of length n + 1",
      "code": "int a [ n + 1 ] ;",
      "indent": 1
    },
    {
      "line": 43,
      "text": "for i from 1 to n",
      "code": "for ( int i = 1 ; i <= n ; i ++ )",
      "indent": 1
    },
    {
      "line": 44,
      "text": "read a [ i ]",
      "code": "cin >> a [ i ] ;",
      "indent": 2
    },
    {
      "line": 45,
      "text": "if m > a [ i ]",
      "code": "if ( m > a [ i ] )",
      "indent": 2
    },
    {
      "line": 46,
      "text": "set m to a [ i ]",
      "code": "m = a [ i ] ;",
      "indent": 3
    },
    {
      "line": 47,
      "text": "set index to i",
      "code": "index = i ;",
      "indent": 3
    },
    {
      "line": 48,
      "text": "DUMMY",
      "code": "}",
      "indent": 2
    },
    {
      "line": 49,
      "text": "DUMMY",
      "code": "}",
      "indent": 1
    },
    {
      "line": 50,
      "text": "let c an int with value 0",
      "code": "int c = 0 ;",
      "indent": 1
    },
    {
      "line": 51,
      "text": "for i from 1 to n",
      "code": "for ( int i = 1 ; i <= n ; i ++ )",
      "indent": 1
    },
    {
      "line": 52,
      "text": "if a [ i ] is m , increment c",
      "code": "if ( a [ i ] == m ) c ++ ;",
      "indent": 2
    },
    {
      "line": 53,
      "text": "if c at least 2 , end loop",
      "code": "if ( c >= 2 ) break ;",
      "indent": 2
    },
    {
      "line": 54,
      "text": "DUMMY",
      "code": "}",
      "indent": 1
    },
    {
      "line": 55,
      "text": "if c at least 2",
      "code": "if ( c >= 2 )",
      "indent": 1
    },
    {
      "line": 56,
      "text": "print Still Rozdil",
      "code": "cout << \" Still Rozdil\\n \" ;",
      "indent": 2
    },
    {
      "line": 57,
      "text": "otherwise",
      "code": "else",
      "indent": 1
    },
    {
      "line": 58,
      "text": "print index",
      "code": "cout << index << endl ;",
      "indent": 2
    },
    {
      "line": 59,
      "text": "DUMMY",
      "code": "return 0;",
      "indent": 1
    },
    {
      "line": 60,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    }
  ],
  "errors": [
    {
      "mod_line": [
        2
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        26
      ],
      "mod_code": [
        "void swap ( int x , char y )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        28
      ],
      "mod_code": [
        "temp = y [ y ] ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29
      ],
      "mod_code": [
        "y [ y ] = { x } ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        30
      ],
      "mod_code": [
        "x = temp ;"
      ],
      "err_line": 30,
      "err_msg": "invalid conversion from ‘char’ to ‘char*’ [-fpermissive]"
    },
    {
      "mod_line": [
        45
      ],
      "mod_code": [
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 45,
      "err_msg": "invalid types ‘int[int]’ for array subscript"
    },
    {
      "mod_line": [
        56
      ],
      "mod_code": [
        "cout << Still << endl ;"
      ],
      "err_line": 56,
      "err_msg": "‘Still’ was not declared in this scope"
    },
    {
      "mod_line": [
        1
      ],
      "mod_code": [
        "double gcd ( double a and double b )"
      ],
      "err_line": 1,
      "err_msg": "expected ‘,’ or ‘...’ before ‘and’ token"
    },
    {
      "mod_line": [
        2
      ],
      "mod_code": [
        "return a < 0 ? b : fmod ( fmod , a ) ;"
      ],
      "err_line": 2,
      "err_msg": "no matching function for call to ‘fmod(<unresolved overloaded function type>, double&)’"
    },
    {
      "mod_line": [
        4
      ],
      "mod_code": [
        "long long int max ( long long int a and long long int b )"
      ],
      "err_line": 4,
      "err_msg": "expected ‘,’ or ‘...’ before ‘and’ token"
    },
    {
      "mod_line": [
        8
      ],
      "mod_code": [
        "max ( b , c ) , max ( a , result ) ;"
      ],
      "err_line": 8,
      "err_msg": "‘result’ was not declared in this scope"
    },
    {
      "mod_line": [
        10
      ],
      "mod_code": [
        "long long int min ( long long int a and long long int b )"
      ],
      "err_line": 10,
      "err_msg": "expected ‘,’ or ‘...’ before ‘and’ token"
    },
    {
      "mod_line": [
        14
      ],
      "mod_code": [
        "min ( b , c ) , min ( a , result ) ;"
      ],
      "err_line": 14,
      "err_msg": "‘result’ was not declared in this scope"
    },
    {
      "mod_line": [
        17
      ],
      "mod_code": [
        "long long int res a = 1 ;"
      ],
      "err_line": 17,
      "err_msg": "expected initializer before ‘a’"
    },
    {
      "mod_line": [
        18
      ],
      "mod_code": [
        "int x = x % MOD ;"
      ],
      "err_line": 18,
      "err_msg": "declaration of ‘int x’ shadows a parameter"
    },
    {
      "mod_line": [
        20
      ],
      "mod_code": [
        "if ( y & 1 ) res to ( res * x ) % MOD ;"
      ],
      "err_line": 20,
      "err_msg": "expected ‘;’ before ‘to’"
    },
    {
      "mod_line": [
        22
      ],
      "mod_code": [
        "x = ( x * x ) mod MOD ;"
      ],
      "err_line": 22,
      "err_msg": "expected ‘;’ before ‘mod’"
    },
    {
      "mod_line": [
        26
      ],
      "mod_code": [
        "void swap ( int * x , char y )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        29
      ],
      "mod_code": [
        "y [ y ] = { 0 } ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        35
      ],
      "mod_code": [
        "otherwise"
      ],
      "err_line": 35,
      "err_msg": "‘otherwise’ was not declared in this scope"
    },
    {
      "mod_line": [
        44
      ],
      "mod_code": [
        "cin >> a . at ( i ) ;"
      ],
      "err_line": 44,
      "err_msg": "request for member ‘at’ in ‘a’, which is of non-class type ‘int [(n + 1)]’"
    },
    {
      "mod_line": [
        50
      ],
      "mod_code": [
        "int c an 0 ;"
      ],
      "err_line": 50,
      "err_msg": "expected initializer before ‘an’"
    },
    {
      "mod_line": [
        56
      ],
      "mod_code": [
        "cout << Still << ' \\n ' ;"
      ],
      "err_line": 56,
      "err_msg": "‘Still’ was not declared in this scope"
    },
    {
      "mod_line": [
        57
      ],
      "mod_code": [
        "otherwise"
      ],
      "err_line": 57,
      "err_msg": "‘otherwise’ was not declared in this scope"
    },
    {
      "mod_line": [
        2,
        26
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        28
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "temp = y [ y ] ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        28,
        29
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        28,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        28,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        28,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        29
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        29,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        29,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        29,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        30,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        30,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        45,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        26,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "void swap ( int x , char y )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        29
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        29,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        29,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        29,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        30,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        30,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        45,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        28,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "temp = y [ y ] ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        30,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        30,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        45,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        29,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        30
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "x = temp ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        30,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        30,
        45,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        30,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        45
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        45,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        2,
        56
      ],
      "mod_code": [
        "return a < 0 ? b : gcd ( fmod , a ) ;",
        "cout << Still << endl ;"
      ],
      "err_line": 2,
      "err_msg": "cannot resolve overloaded function ‘fmod’ based on conversion to type ‘double’"
    },
    {
      "mod_line": [
        26,
        28
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        29
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        29,
        30
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        29,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        29,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        30
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        30,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        30,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        45,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        28,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "temp = y [ y ] ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char[char]’ for array subscript"
    },
    {
      "mod_line": [
        26,
        29
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        30
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        30,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        30,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        45,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        29,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        30
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        30,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        30,
        45,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        30,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        45
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        45,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        26,
        56
      ],
      "mod_code": [
        "void swap ( int x , char y )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid type argument of unary ‘*’ (have ‘char’)"
    },
    {
      "mod_line": [
        28,
        29
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        30
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        30,
        45
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        30,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        45
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        45,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        29,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        30
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "x = temp ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        30,
        45
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        30,
        45,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        30,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        45
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        45,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        28,
        56
      ],
      "mod_code": [
        "temp = y [ y ] ;",
        "cout << Still << endl ;"
      ],
      "err_line": 28,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        30
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "x = temp ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        30,
        45
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        30,
        45,
        56
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        30,
        56
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        45
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        45,
        56
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        29,
        56
      ],
      "mod_code": [
        "y [ y ] = { x } ;",
        "cout << Still << endl ;"
      ],
      "err_line": 29,
      "err_msg": "invalid types ‘char*[char*]’ for array subscript"
    },
    {
      "mod_line": [
        30,
        45
      ],
      "mod_code": [
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )"
      ],
      "err_line": 30,
      "err_msg": "invalid conversion from ‘char’ to ‘char*’ [-fpermissive]"
    },
    {
      "mod_line": [
        30,
        45,
        56
      ],
      "mod_code": [
        "x = temp ;",
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 30,
      "err_msg": "invalid conversion from ‘char’ to ‘char*’ [-fpermissive]"
    },
    {
      "mod_line": [
        30,
        56
      ],
      "mod_code": [
        "x = temp ;",
        "cout << Still << endl ;"
      ],
      "err_line": 30,
      "err_msg": "invalid conversion from ‘char’ to ‘char*’ [-fpermissive]"
    },
    {
      "mod_line": [
        45,
        56
      ],
      "mod_code": [
        "if ( m [ i ] > a [ i ] )",
        "cout << Still << endl ;"
      ],
      "err_line": 45,
      "err_msg": "invalid types ‘int[int]’ for array subscript"
    }
  ]
}