{
  "meta": {
    "index": 591,
    "hitid": "3SU800BH86M9FKGT69NBV52REWVUQD",
    "workerid": "A1AYVATMT88U1W",
    "probid": "593A",
    "subid": "17878804"
  },
  "lines": [
    {
      "line": 0,
      "text": "let size_n be a integer",
      "code": "int size_n ;",
      "indent": 0
    },
    {
      "line": 1,
      "text": "letters = array of characters of length 26",
      "code": "char letters [ 26 ] ;",
      "indent": 0
    },
    {
      "line": 2,
      "text": "let result be a integer with result = 0",
      "code": "int result = 0 ;",
      "indent": 0
    },
    {
      "line": 3,
      "text": "create a vector of strings str ( 0 )",
      "code": "vector < string > str ( 0 ) ;",
      "indent": 0
    },
    {
      "line": 4,
      "text": "let check be a function that accepts characters a , b and returns a integer",
      "code": "int check ( char a , char b ) ;",
      "indent": 0
    },
    {
      "line": 5,
      "text": "DUMMY",
      "code": "int main() {",
      "indent": 0
    },
    {
      "line": 6,
      "text": "let ii , jj be integers",
      "code": "int ii , jj ;",
      "indent": 1
    },
    {
      "line": 7,
      "text": "read size_n",
      "code": "cin >> size_n ;",
      "indent": 1
    },
    {
      "line": 8,
      "text": "str . resize ( size_n )",
      "code": "str . resize ( size_n ) ;",
      "indent": 1
    },
    {
      "line": 9,
      "text": "cin . ignore ( )",
      "code": "cin . ignore ( ) ;",
      "indent": 1
    },
    {
      "line": 10,
      "text": "for ii = 0 to 26 exclusive , letters [ ii ] is equal to a + ii",
      "code": "for ( ii = 0 ; ii < 26 ; ii ++ ) letters [ ii ] = ' a ' + ii ;",
      "indent": 1
    },
    {
      "line": 11,
      "text": "for ii = 0 to size_n exclusive , getline ( cin , str [ ii ] )",
      "code": "for ( ii = 0 ; ii < size_n ; ii ++ ) getline ( cin , str [ ii ] ) ;",
      "indent": 1
    },
    {
      "line": 12,
      "text": "for ii = 0 to 26 exclusive",
      "code": "for ( ii = 0 ; ii < 26 ; ii ++ )",
      "indent": 1
    },
    {
      "line": 13,
      "text": "for jj = ( ii + 1 ) to 26 exclusive , result = maximum of result and check ( letters [ ii ] , letters [ jj ] )",
      "code": "for ( jj = ( ii + 1 ) ; jj < 26 ; jj ++ ) result = max ( result , check ( letters [ ii ] , letters [ jj ] ) ) ;",
      "indent": 2
    },
    {
      "line": 14,
      "text": "DUMMY",
      "code": "}",
      "indent": 1
    },
    {
      "line": 15,
      "text": "print result and newline",
      "code": "cout << result << endl ;",
      "indent": 1
    },
    {
      "line": 16,
      "text": "DUMMY",
      "code": "return 0;",
      "indent": 1
    },
    {
      "line": 17,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    },
    {
      "line": 18,
      "text": "let check be a function that accepts characters a , b and returns a integer",
      "code": "int check ( char a , char b )",
      "indent": 0
    },
    {
      "line": 19,
      "text": "let ii , jj be integers",
      "code": "int ii , jj ;",
      "indent": 1
    },
    {
      "line": 20,
      "text": "let wordLen be a integer",
      "code": "int wordLen ;",
      "indent": 1
    },
    {
      "line": 21,
      "text": "let niceWord be a boolean value",
      "code": "bool niceWord ;",
      "indent": 1
    },
    {
      "line": 22,
      "text": "let res be a integer with res = 0",
      "code": "int res = 0 ;",
      "indent": 1
    },
    {
      "line": 23,
      "text": "for ii = 0 to size_n exclusive",
      "code": "for ( ii = 0 ; ii < size_n ; ii ++ )",
      "indent": 1
    },
    {
      "line": 24,
      "text": "wordLen is equal to length of str [ ii ]",
      "code": "wordLen = str [ ii ] . size ( ) ;",
      "indent": 2
    },
    {
      "line": 25,
      "text": "niceWord is equal to 1",
      "code": "niceWord = 1 ;",
      "indent": 2
    },
    {
      "line": 26,
      "text": "for jj is equal to 0 , ( jj is less than wordLen ) and niceWord , increment jj by 1",
      "code": "for ( jj = 0 ; ( jj < wordLen ) && niceWord ; jj ++ )",
      "indent": 2
    },
    {
      "line": 27,
      "text": "if str [ ii ] [ jj ] is not equal to a and str [ ii ] [ jj ] is not equal to b , niceWord is equal to 0",
      "code": "if ( ( str [ ii ] [ jj ] != a ) && ( str [ ii ] [ jj ] != b ) ) niceWord = 0 ;",
      "indent": 3
    },
    {
      "line": 28,
      "text": "DUMMY",
      "code": "}",
      "indent": 2
    },
    {
      "line": 29,
      "text": "if niceWord , increment res by wordLen",
      "code": "if ( niceWord ) res += wordLen ;",
      "indent": 2
    },
    {
      "line": 30,
      "text": "DUMMY",
      "code": "}",
      "indent": 1
    },
    {
      "line": 31,
      "text": "return the value of res",
      "code": "return res ;",
      "indent": 1
    },
    {
      "line": 32,
      "text": "DUMMY",
      "code": "}",
      "indent": 0
    }
  ],
  "errors": [
    {
      "mod_line": [
        4
      ],
      "mod_code": [
        "int check ( char a , char b )"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        10
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        13
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        1
      ],
      "mod_code": [
        "char letters [ 26 ] [ 26 ] ;"
      ],
      "err_line": 10,
      "err_msg": "incompatible types in assignment of ‘int’ to ‘char [26]’"
    },
    {
      "mod_line": [
        2
      ],
      "mod_code": [
        "result = 0 ;"
      ],
      "err_line": 2,
      "err_msg": "‘result’ does not name a type"
    },
    {
      "mod_line": [
        3
      ],
      "mod_code": [
        "bool str ( 0 ) ;"
      ],
      "err_line": 8,
      "err_msg": "request for member ‘resize’ in ‘str’, which is of non-class type ‘bool’"
    },
    {
      "mod_line": [
        4
      ],
      "mod_code": [
        "int check ( int a , char b )"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        7
      ],
      "mod_code": [
        "gets ( size_n ) ;"
      ],
      "err_line": 7,
      "err_msg": "invalid conversion from ‘int’ to ‘char*’ [-fpermissive]"
    },
    {
      "mod_line": [
        9
      ],
      "mod_code": [
        "cin . ignore ( ) ) ;"
      ],
      "err_line": 9,
      "err_msg": "expected ‘;’ before ‘)’ token"
    },
    {
      "mod_line": [
        13
      ],
      "mod_code": [
        "for ( jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; }"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        4,
        10
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        13
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        13,
        26
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        13,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        13,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        26
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        10,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13,
        26
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        13,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        26
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        26,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        4,
        27
      ],
      "mod_code": [
        "int check ( char a , char b )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 5,
      "err_msg": "expected initializer before ‘int’"
    },
    {
      "mod_line": [
        10,
        13
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        13,
        26
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        13,
        26,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        13,
        26,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        13,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        13,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        26
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        26,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        26,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        10,
        27
      ],
      "mod_code": [
        "for ( int ii = 0 ; ii < 26 ; ii ++ ) { letters [ ii ] = a + ii ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 10,
      "err_msg": "‘a’ was not declared in this scope"
    },
    {
      "mod_line": [
        13,
        26
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        13,
        26,
        27
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        13,
        26,
        27
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "for ( jj = 0 ; jj < wordLen ; jj ++ ) { jj ++ ; }",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        13,
        27
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) niceWord = 0 ;"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    },
    {
      "mod_line": [
        13,
        27
      ],
      "mod_code": [
        "for ( int jj = ( ii + 1 ) ; jj < 26 && check ( letters [ ii ] , letters [ jj ] , letters [ jj ] ) ; ++ jj )",
        "if ( str [ ii ] [ jj ] != b && str [ ii ] [ jj ] != b ) { niceWord = 0 ; }"
      ],
      "err_line": 13,
      "err_msg": "too many arguments to function ‘int check(char, char)’"
    }
  ]
}